*autocmd.txt*   Pour Vim version 7.0. Dernier changement : 16 janvier 2007


		 MANUEL de RÉFÉRENCE VIM - par Bram Moolenaar


Commandes automatiques					*autocommand*

Ce sujet est abordé dans la section |40.3| du Manuel de l'utilisateur.

1.  Introduction	                |autocmd-intro|
2.  Définir des autocommandes           |autocmd-define|
3.  Supprimer des autocommandes         |autocmd-remove|
4.  Lister des autocommandes	        |autocmd-list|
5.  Événements			        |autocmd-events|
6.  Motifs			        |autocmd-patterns|
7.  Autocommandes locales à un tampon   |autocmd-buflocal|
8.  Groupes		                |autocmd-groups|
9.  Exécuter des autocommandes          |autocmd-execute|
10. Utiliser des autocommandes          |autocmd-use|
11. Désactiver des autocommandes        |autocmd-disable|

{absent de Vi}
{seulement si la fonctionnalité |+autocmd| n'a pas été désactivée lors de la
compilation}

==============================================================================
1. Introduction						*autocmd-intro*

Vous pouvez spécifier des commandes qui s'exécuteront automatiquement lors de
la lecture ou de l'écriture d'un fichier, à l'entrée ou à la sortie d'un
tampon ou d'une fenêtre, et lorsque vous quitterez Vim. Par exemple, vous
pouvez créer une autocommande pour activer l'option 'cindent' pour tous les
fichiers correspondant à "*.c". Vous pouvez aussi utiliser les autocommandes
pour mettre en oeuvre des fonctionnalités avancées, comme l'édition de
fichiers compactés (voir |gzip-example|). Le meilleur endroit pour mettre vos
autocommandes est votre fichier vimrc ou exrc.

							*E203* *E204* *E143*
ATTENTION ! L'utilisation des autocommandes se révèle particulièrement
puissante et peut engendrer des effets de bord indésirables. Veillez à ce
qu'elles n'endommagent pas votre texte.
- Il est plus prudent de faire quelques essais avec la copie d'un fichier en
  premier lieu. Par exemple : si vous utilisez des autocommandes pour
  décompacter un fichier quand vous commencez à l'éditer, assurez-vous que les
  autocommandes chargées de le compacter quand vous l'enregistrez fonctionnent
  correctement.
- Vous aurez peut-être à faire face à des erreurs survenant en cours
  d'exécution (p. ex., disque plein). Vim devrait être capable d'annuler les
  changements opérés sur le tampon dans la plupart des cas, mais vous devrez
  nettoyer les autres fichiers à la main (p. ex., compacter un fichier qui a
  été décompacté).
- Si les événements BufRead* vous autorisent à éditer un fichier compacté, il
  devrait en être de même pour les événements FileRead* (cela peut autoriser
  le recouvrement dans certains cas). Essayez d'utiliser les mêmes
  autocommandes pour les événements File* et Buf* quand c'est possible.

==============================================================================
2. Définir des autocommandes				*autocmd-define*

NOTE : La commande ":autocmd" ne peut pas être suivie par une autre commande,
car le '|' est considéré comme une partie de la commande.

							*:au* *:autocmd*
:au[tocmd] [groupe] {even} {motif} [nested] {cmd}
			Ajoute {cmd} à la liste des commandes que Vim
			exécutera automatiquement à l'{even}ement pour un
			fichier correspondant à {motif}. Vim ajoute toujours
			la commande {cmd} après les autocommandes existantes,
			les autocommandes sont ainsi exécutées dans l'ordre où
			elles sont données.
			Voir |autocmd-nested| pour [nested].

Le motif spécial <buffer> ou <buffer=N> permet de définir une autocommande
locale à un tampon. Voir |autocmd-buflocal|.

NOTE : Les caractères spéciaux (p. ex., "%" ou "<cword>") dans les arguments
de ":autocmd" ne sont pas étendus lorsque l'autocommande est définie. Ils le
seront quand l'{even}ement sera reconnu, et la {cmd} exécutée. La seule
exception à cette règle est "<sfile>", qui est étendu lorsque l'autocommande
est définie. Exemple : >

	:au BufNewFile,BufRead *.html so <sfile>:h/html.vim

Ici, Vim étend <sfile> au nom du fichier contenant cette ligne.

Si votre fichier vimrc est sourcé deux fois, les autocommandes qu'il contient
apparaîtront deux fois. Pour éviter ceci, placez cette commande dans votre
fichier vimrc, avant de définir les autocommandes : >

	:autocmd!	" Supprime TOUTES les autocmd pour le groupe courant.

Si vous ne souhaitez pas supprimer toutes les autocommandes, vous pouvez à la
place utiliser une variable pour tester si Vim a déjà défini les autocommandes
ou pas : >

	:if !exists("autocommandes_incluses")
	:  let autocommandes_incluses = 1
	:  au ...
	:endif

Si l'argument [groupe] n'est pas donné, Vim utilise le groupe courant (comme
défini avec ":augroup") ; sinon, Vim utilise le groupe donné par [groupe].
   NOTE : [groupe] doit avoir été défini auparavant. Vous ne pouvez pas
définir un nouveau groupe avec ":au groupe ..." ; utilisez ":augroup" pour
cela.

Lors de tests d'autocommandes, l'option 'verbose' vous sera probablement
utile : >
	:set verbose=9
Ceci indique à Vim d'afficher les autocommandes au fur et à mesure qu'il les
exécute.

Si vous définissez une autocommande dans un script, elle sera capable
d'appeler des fonctions locales au script et d'utiliser des mappages locaux au
script. Quand l'événement est déclenché et la commande exécutée, elle sera
lancée dans le contexte du script dans lequel elle a été définie. Cela pose
problème lorsque |<SID>| est utilisé dans une commande.

Lors de l'exécution des commandes, les messages émis par une commande
effaceront les messages précédents. Cela diffère de l'exécution manuelle des
commandes. La plupart du temps, l'écran ne sera pas décalé vers le haut, il
n'y aura donc pas d'invite Appuyez-sur-entrée. Néanmoins, cela peut se
produire si une commande renvoie deux messages.

==============================================================================
3. Supprimer des autocommandes				*autocmd-remove*

:au[tocmd]! [groupe] {even} {motif} [nested] {cmd}
			Supprime toutes les autocommandes associées à {even}
			et {motif}, et ajoute la commande {cmd}. Voir
			|autocmd-nested| pour [nested].

:au[tocmd]! [groupe] {even} {motif}
			Supprime toutes les autocommandes associées à {even}
			et {motif}.

:au[tocmd]! [groupe] * {motif}
			Supprime toutes les autocommandes associées à {motif}
			pour tous les événements.

:au[tocmd]! [groupe] {even}
			Supprime TOUTES les autocommandes pour {even}.

:au[tocmd]! [groupe]	Supprime TOUTES les autocommandes.

Si l'argument [groupe] n'est pas donné, Vim utilise le groupe courant (comme
défini avec ":augroup") ; sinon, Vim utilise le groupe donné par [groupe].

==============================================================================
4. Lister des autocommandes		    		*autocmd-list*

:au[tocmd] [groupe] {even} {motif}
			Affiche toutes les autocommandes associées à {even}
			et {motif}.

:au[tocmd] [groupe] * {motif}
			Affiche toutes les autocommandes associées à {motif}
			pour tous les événements.

:au[tocmd] [groupe] {even}
			Affiche toutes les autocommandes pour {even}.

:au[tocmd] [groupe]	Affiche toutes les autocommandes.

Si l'argument [groupe] est donné, Vim ne listera que les autocommandes pour
[groupe] ; sinon, Vim listera les autocommandes pour TOUS les groupes.
   NOTE : Le comportement de cet argument est différent quand vous définissez
ou supprimez des autocommandes.

Afin de lister les autocommandes locales à un tampon, utilisez un motif de la
forme <buffer> ou <buffer=N>. Voir |autocmd-buflocal|.

                                                        *:autocmd-verbose*
Lorsque l'option 'verbose' est non nulle, le listage d'une autocommande
affichera également l'endroit où elle a été définie en dernier.
Par exemple : >

    :verbose autocmd BufEnter
    FileExplorer  BufEnter
       *         call s:LocalBrowse(expand("<amatch>"))
           Last set from /usr/share/vim/vim-7.0/plugin/NetrwPlugin.vim
<
Voir |:verbose-cmd| pour de plus amples informations.

==============================================================================
5. Événements					*autocmd-events* *E215* *E216*

Vous pouvez spécifier une liste de noms d'événements séparés par des virgules.
Aucun caractère d'espacement ne peut être utilisé dans cette liste. Les
commandes s'appliquent alors à tous les événements de la liste.

Lors de la LECTURE D'UN FICHIER, il y a quatre types d'événements possibles :
        BufNewFile                      début de l'édition d'un fichier
                                        qui n'existait pas.
        BufReadPre BufReadPost          début de l'édition d'un fichier
                                        existant
        FilterReadPre FilterReadPost    lecture d'un fichier depuis une
                                        commande de filtre
        FileReadPre FileReadPost        lecture d'un autre fichier
Vim n'utilise que l'un de ces quatre types d'événements à la lecture d'un
fichier. Les événements « Pre » et « Post » sont déclenchés avant et après la
lecture du fichier, respectivement.

Notez que les autocommandes pour les événements « *ReadPre » et pour tous les
événements « Filter » ne peuvent pas modifier le tampon courant (vous
obtiendrez un message d'erreur s'ils essayent). Cela permet d'éviter que le
fichier soit lu dans le mauvais tampon.

Notez également que le drapeau 'modified' n'est réinitialisé que APRÈS
l'exécution des autocommandes BufReadPost et BufNewFile. Mais lorsque l'option
'modified' a été positionné par les autocommandes, elle ne change pas.

Vous pouvez utiliser l'option 'eventignore' pour ignorer certains événements
(ou tous).
				    *autocommand-events* *{event}* *{even}*
Vim reconnaît les événements suivants. Vim ignore la casse du nom des
événements (p. ex., vous pouvez écrire « BUFread » ou « bufread » au lieu de
« BufRead »).

Premièrement voici une vue d'ensemble par fonctionnalité avec une explication
courte. Puis une liste alphabétique avec des explications complètes
|autocmd-events-abc|.

Nom                     déclenché par ~

        Lecture
|BufNewFile|            début de l'édition d'un nouveau fichier
|BufReadPre|            début de l'édition d'un nouveau tampon, avant la
                        lecture du fichier
|BufRead|               début de l'édition d'un nouveau tampon, après la
                        lecture du fichier
|BufReadPost|           début de l'édition d'un nouveau tampon, après la
                        lecture du fichier
|BufReadCmd|            avant l'édition d'un nouveau tampon |Cmd-event|

|FileReadPre|           avant la lecture d'un fichier avec une commande ":read"
|FileReadPost|          après la lecture d'un fichier avec une commande ":read"
|FileReadCmd|           avant la lecture d'un fichier avec une commande ":read"
                        |Cmd-event|

|FilterReadPre|         avant la lecture d'un fichier depuis une commande de
                        filtre
|FilterReadPost|        après la lecture d'un fichier depuis une commande de
                        filtre

|StdinReadPre|          avant la lecture de depuis from stdin vers le tampon
|StdinReadPost|         après la lecture de depuis from stdin vers le tampon

        Écriture
|BufWrite|              avant l'écriture de tout le tampon dans un fichier
|BufWritePre|           avant l'écriture de tout le tampon dans un fichier
|BufWritePost|          après l'écriture de tout le tampon dans un fichier
|BufWriteCmd|           avant l'écriture de tout le tampon dans un fichier
                        |Cmd-event|

|FileWritePre|          avant l'écriture d'une partie du tampon dans un
                        fichier
|FileWritePost|         après l'écriture d'une partie du tampon dans un
                        fichier
|FileWriteCmd|          avant l'écriture d'une partie du tampon dans un
                        fichier |Cmd-event|

|FileAppendPre|         début d'ajout à un fichier
|FileAppendPost|        après avoir ajouté à un fichier
|FileAppendCmd|         avant d'ajouter à un fichier |Cmd-event|

|FilterWritePre|        début d'écriture d'un fichier pour un filtre ou un
                        diff
|FilterWritePost|       après l'écriture d'un fichier pour un filtre ou un
                        diff

        Tampons
|BufAdd|                juste après avoir ajouté un tampon à la liste des
                        tampons
|BufCreate|             juste après avoir ajouté un tampon à la liste des
                        tampons
|BufDelete|             avant la suppression d'un tampon de la liste des
                        tampons
|BufWipeout|            avant la suppression complète d'un tampon

|BufFilePre|            avant de changer le nom du tampon courant
|BufFilePost|           après le changement du nom du tampon courant

|BufEnter|              après être entré dans un tampon
|BufLeave|              avant de sortir d'un tampon pour aller dans un notre
|BufWinEnter|           après qu'un tampon ait été affiché dans une fenêtre
|BufWinLeave|           avant qu'un tampon soit supprimé d'une fenêtre

|BufUnload|             avant de décharger un tampon
|BufHidden|             juste après qu'un tampon ait été caché
|BufNew|                juste après la création d'un tampon

|SwapExists|            après la détection d'un fichier d'échange existant

        Options
|FileType|              lorsque l'option 'filetype' vient d'être changée
|Syntax|                lorsque l'option 'syntax' vient d'être changée
|EncodingChanged|       lorsque l'option 'encoding' vient d'être changée
|TermChanged|           lorsque l'option 'term' vient d'être changée

        Démarrage et fin
|VimEnter|              après avoir effectué tout les trucs du démarrage
|GUIEnter|              après avoir démarré l'IHM correctement
|TermResponse|          après que la réponse de terminal |t_RV| ait été reçue

|VimLeavePre|           avant de quitter Vim, juste avant d'écrire le fichier
                        viminfo
|VimLeave|              avant de quitter Vim, après avoir écrit le fichier
                        viminfo

        Divers
|FileChangedShell|      Vim s'est aperçu que le fichier avait changé depuis le
                        début de l'édition
|FileChangedShellPost|  après s'être chargé d'un changement du fichier depuis
                        le début de l'édition
|FileChangedRO|         avant d'effectuer le premier changement sur un fichier
                        ouvert en lecture seule

|ShellCmdPost|          après l'exécution d'une commande shell
|ShellFilterPost|       après avoir filtré avec une commande shell

|FuncUndefined|         une fonction utilisateur a été utilisée alors qu'elle
                        n'est pas définie
|SpellFileMissing|      Un fichier d'orthographe est utilisé mais ne peut pas
                        être trouvé
|SourcePre|             avant d'exécuter un script Vim
|SourceCmd|             avant d'exécuter un script Vim |Cmd-event|

|VimResized|            après que la fenêtre Vim a changé de taille
|FocusGained|           Vim vient de recevoir le focus clavier
|FocusLost|             Vim vient de perdre le focus clavier
|CursorHold|            l'utilisateur n'a pas pressé de touche depuis un
                        moment
|CursorHoldI|           l'utilisateur n'a pas pressé de touche depuis un
                        moment alors que l'on est en mode insertion
|CursorMoved|           le curseur a été déplacé en mode normal
|CursorMovedI|          le curseur a été déplacé en mode insertion

|WinEnter|              après être entré dans une autre fenêtre
|WinLeave|              avant de sortir d'une fenêtre
|TabEnter|              après être entré dans une autre page à onglet
|TabLeave|              avant de sortir d'une page à onglet
|CmdwinEnter|           après être entré dans la fenêtre de ligne de commandes
|CmdwinLeave|           avant de sortir de la fenêtre de ligne de commandes

|InsertEnter|           commencement du mode insertion
|InsertChange|          lors de l'utilisation de la touche <Insert> en étant
                        dans le mode insertion ou replacement
|InsertLeave|           quand on sort du mode insertion

|ColorScheme|           après avoir chargé un nouveau shéma de couleurs

|RemoteReply|           une réponse d'un serveur Vim a été reçu

|QuickFixCmdPre|        avant qu'une commande quickfix soit exécutée
|QuickFixCmdPost|       après qu'une commande quickfix a été exécutée

|SessionLoadPost|       après le chargement d'un fichier de session

|MenuPopup|             juste avant de montrer le menu popup

|User|                  pour utiliser avec ":doautocmd"

La liste alphabétique des événements pour les autocommandes :
                                                        *autocmd-events-abc*

BufCreate	ou					*BufCreate* *BufAdd*
BufAdd			Juste après la création d'un nouveau tampon qui sera
			ajouté à la liste des tampons, ou après l'ajout d'un
			tampon à cette liste.
			Également utilisé juste après qu'un tampon de la
			liste des tampons a été renommé.
			L'événement BufCreate assure la compatibilité avec les
			versions antérieures.
			NOTE : Lorsque cette autocommande est exécutée, le
			tampon courant "%" peut être différent du tampon qui a
			été créé "<afile>".
							*BufDelete*
BufDelete		Avant la suppression d'un tampon de la liste des
			tampons. BufUnload peut être appelé en premier (si le
			tampon était chargé).
			Également utilisé juste avant qu'un tampon de la liste
			des tampons soit renommé.
			NOTE : Lorsque cette autocommande est exécutée, le
			tampon courant "%" peut être différent du tampon qui a
			été supprimé "<afile>".
							*BufEnter*
BufEnter		Après l'entrée dans un tampon. Utile pour fixer des
			options pour un type de fichier. Également exécuté
			quand un tampon commence à être édité, après les
			autocommande BufReadPost.
							*BufFilePost*
BufFilePost		Après avoir changé le nom du tampon courant avec les
			commandes ":file" ou ":saveas".
							*BufFilePre*
BufFilePre		Avant de changer le nom du tampon courant avec les
			commandes ":file" ou ":saveas".
							*BufHidden*
BufHidden		Juste après qu'un tampon a été caché, c'est-à-dire
			quand il n'y a plus de fenêtres qui affichent le
			tampon, mais qu'il n'est pas déchargé ou supprimé. Non
			utilisé pour ":qa" ou ":q" quand Vim est quitté.
			NOTE : Lorsque cette autocommande est exécutée, le
			tampon courant "%" peut être différent du tampon qui a
			été déchargé "<afile>".
							*BufLeave*
BufLeave		Avant de quitter le tampon pour un autre. Également
			quand la fenêtre courante est quittée ou fermée et que
			la nouvelle fenêtre courante ne contient pas le même
			tampon. Non utilisé pour ":qa" ou ":q" quand Vim est
			quitté.
							*BufNew*
BufNew			Juste après la création d'un nouveau tampon. Également
			utilisé juste après qu'un tampon a été renommé. Quand
			le tampon est ajouté à la liste des tampons, BufAdd
			sera déclenché.
			NOTE : Lorsque cette autocommande est exécutée, le
			tampon courant "%" peut être différent du tampon qui a
			été créé "<afile>".
							*BufNewFile*
BufNewFile		Quand un fichier qui n'existe pas commence à être
			édité. Peut servir à lire dans un squelette de
			fichier.
BufReadPost	ou				*BufRead* *BufReadPost*
BufRead			Quand un nouveau fichier commence à être édité, après
			la lecture du fichier dans le tampon, avant
			l'exécution des lignes de mode. Voir |BufWinEnter| si
			vous avez besoin d'effectuer quelque chose après
			l'exécution des lignes de mode.
			Ceci ne fonctionne PAS pour ":r fichier". Non utilisé
			si le fichier n'existe pas. Également utilisé après le
			recouvrement réussi d'un fichier.
							*BufReadCmd*
BufReadCmd		Avant de commencer l'édition d'un nouveau tampon.
			Devrait lire le tampon dans le fichier. |Cmd-event|
						*BufReadPre* *E200* *E201*
BufReadPre		Quand un nouveau fichier commence à être édité, avant
			la lecture du fichier dans le tampon. Non utilisé si
			le fichier n'existe pas.
							*BufUnload*
BufUnload		Avant le déchargement d'un tampon, c'est-à-dire quand
			le texte dans le tampon va être libéré. Cela peut être
			après un BufWritePost et avant un BufDelete. Également
			utilisé pour tous les tampons qui sont chargés quand
			Vim va être quitté.
			NOTE : Lorsque cette autocommande est exécutée, le
			tampon courant "%" peut être différent du tampon qui a
			été déchargé "<afile>".
							*BufWinEnter*
BufWinEnter		Après l'affichage d'un tampon dans une fenêtre. Cela
			peut être lors du chargement du tampon (après
			traitement des lignes de mode), lorsqu'un tampon caché
			est affiché dans une fenêtre (il n'est alors plus
			caché) ou lorsqu'un tampon déjà visible est à nouveau
			affiché dans une autre fenêtre.
							*BufWinLeave*
BufWinLeave		Avant qu'un tampon ne soit supprimé d'une fenêtre,
			mais pas s'il est encore visible dans une autre
			fenêtre. Également déclenché quand Vim est quitté.
			Déclenché avant BufUnload ou BufHidden.
			NOTE : Lorsque cette autocommande est exécutée, le
			tampon courant "%" peut être différent du tampon qui a
			été déchargé "<afile>".
							*BufWipeout*
BufWipeout		Avant la suppression complète (la « liquidation »)
			d'un tampon. Les événements BufUnload et BufDelete
			peuvent être appelés en premier (si le tampon était
			chargé et présent dans la liste des tampons).
			Également utilisé juste avant qu'un tampon soit
			renommé (même quand il n'est pas présent dans la liste
			des tampons).
			NOTE : Lorsque cette autocommande est exécutée, le
			tampon courant "%" peut être différent du tampon qui a
			été supprimé "<afile>".
BufWritePre	ou				*BufWrite* *BufWritePre*
BufWrite		Avant l'écriture du tampon entier dans un fichier.
							*BufWriteCmd*
BufWriteCmd		Avant l'écriture du tampon entier dans un fichier.
			Devrait enregistrer le fichier et désactiver
			'modified' si cela a réussi, sauf si '+' est dans
                        l'option 'cpo' et que l'on écrit dans un autre fichier
                        |cpo-+|. Ne devrait pas modifier le tampon. |Cmd-event|
							*BufWritePost*
BufWritePost		Après l'écriture du tampon entier dans un fichier
			(devrait annuler les commandes pour BufWritePre).
							*CmdwinEnter*
CmdwinEnter		Après l'entrée dans la fenêtre command-line. Utile
			pour fixer des options spécifiques à ce type spécial
			de fenêtre. Cet événement est déclenché À LA PLACE de
			BufEnter et WinEnter.
			<afile> est fixé à un caractère simple, indiquant le
			type de la fenêtre command-line. |cmdwin-char|
							*CmdwinLeave*
CmdwinLeave		Avant de quitter la fenêtre command-line. Utile pour
			effacer des paramètres globaux fixés avec CmdwinEnter.
			Cet événement est déclenché À LA PLACE de BufLeave et
			WinLeave.
			<afile> est fixé à un caractère simple, indiquant le
			type de la fenêtre command-line. |cmdwin-char|
                                                        *ColorScheme*
ColorScheme             Après le chargement d'un nouveau schéma de couleur.
                        |:colorscheme|
							*CursorHold*
CursorHold		Quand l'utilisateur n'a pressé aucune touche au bout
			du temps déterminé par 'updatetime'. Non redéclenché
			jusqu'à ce que l'utilisateur presse à nouveau une
			touche (c.-à-d. que cet événement ne se déclenche pas
			toutes les 'updatetime' ms si vous quittez Vim pour
			vous faire du café :). Voir |CursorHold-example| pour
			obtenir un aperçu des marqueurs.
			Cet événement est déclenché uniquement en mode Normal.
                        Lors de l'enregistrement d'une macro, le événement
                        CursorHold n'est pas déclenché. |q|
			NOTE : Les commandes interactives ne peuvent pas être
			utilisées pour cet événement. Il n'aura pas d'invite
			Appuyez-sur-entrée, l'écran sera mis à jour
			directement (si nécessaire).
			NOTE : Dans une version ultérieure, il y aura
			probablement une autre option pour fixer le temps.
			Conseil : Pour forcer la mise à jour des lignes
			d'état, utilisez : >
				:let &ro = &ro
<			{uniquement sur Amiga, Unix, Win32, MS-DOS et toutes
			les versions IHM graphiques}
                                                        *CursorHoldI*
CursorHoldI             Tout comme CursorHold, mais en mode insertion.

                                                        *CursorMoved*
CursorMoved             Après un déplacement du curseur en mode normal.
                        Déclenché également si la ligne sur laquelle le
                        curseur se trouve est modifiée, par exemple par "x",
                        "rx" ou "p". N'est pas déclenché s'il y a du typeahead XXX
                        ou si un opérateur est en attente.
                        Pour un exemple, voir |match-parens|.
                        Attention : ne faites pas quoi que ce soit qui puisse
                        surprendre l'utilisateur ou qui soit lent.
                                                        *CursorMovedI*
CursorMovedI            Après un déplacement du curseur en mode insertion. À
                        part ça, même chose que pour CursorMoved.
							*EncodingChanged*
EncodingChanged		Déclenché quand l'option 'encoding' est modifiée.
			Utile pour changer de police, par exemple.
							*FileAppendCmd*
FileAppendCmd		Avant l'ajout dans un fichier. Devrait effectuer
			l'ajout dans le fichier. Utilisez les marques '[ et
                        '] pour l'étendue des lignes.|Cmd-event|
							*FileAppendPost*
FileAppendPost		Après l'ajout dans un fichier.
							*FileAppendPre*
FileAppendPre		Avant l'ajout dans un fichier. Utilisez les marques '[
                        et '] pour l'étendue des lignes.
							*FileChangedRO*
FileChangedRO		Avant d'effectuer un premier changement dans un
			fichier en lecture seule. Peut être utilisé pour
			automatiser un "checkout" sur un système de gestion de
			versions. Non déclenché si le changement est provoqué
			par une autocommande.
			ATTENTION ! Cet événement est déclenché lorsque le
			changement est effectué, juste avant qu'il ne soit
			appliqué au texte. Si l'autocommande déplace le
			curseur, l'effet du changement est indéfini.
                                                        *E788*
                        Il est interdit de changer de tampon ici. Vous pouvez
                        recharger le tampon mais pas en éditer un nouveau.
							*FileChangedShell*
FileChangedShell	Quand Vim s'aperçoit que la date de modification d'un
			fichier a changé depuis que son édition est commencée.
			|timestamp|
			Déclenché le plus souvent après l'exécution d'une
			commande shell, mais également avec une commande
			|:checktime| ou lorsque Gvim regagne le focus de la
			souris.
			Cette autocommande est déclenchée pour chaque fichier
			modifié. Elle n'est pas utilisée quand 'autoread' est
			activé et que le tampon n'a pas été modifié. Si une
			autocommande FileChangedShell est présente, le message
			d'avertissement et l'invite correspondants ne sont pas
			donnés. C'est utile pour recharger des tampons qui ont
                        un lien qui sont affectés par une seule commande.
                        La variable |v:fcs_reason| est positionnée pour
                        indiquer ce qui vient de se passer et |v:fcs_choice|
                        peut être utilisé pour dire à Vim ce qu'il doit faire
                        ensuite.
			NOTE : Lorsque cette autocommande est exécutée, le
			tampon courant "%" peut être différent du tampon qui a
			été modifié "<afile>".
			NOTE : Les commandes ne doivent pas modifier le tampon
                        courant, basculer vers un autre tampon ou supprimer
                        un tampon.                                      *E246*
			NOTE : Cet événement ne peut pas être imbriqué, pour
			éviter une boucle sans fin. Cela signifie que lors de
			l'exécution de commandes pour l'événement
			FileChangedShell, aucun autre événement
			FileChangedShell ne sera déclenché.
                                                        *FileChangedShellPost*
FileChangedShellPost    Après s'être occupé d'un fichier qui a été changé à
                        l'extérieur de Vim. Peut être utilisé pour mettre à
                        jour la ligne d'état.
							*FileEncoding*
FileEncoding		Obsolète. Est toujours supporté et est équivalent à
			|EncodingChanged|.
							*FileReadCmd*
FileReadCmd		Avant la lecture d'un fichier avec une commande
			":read". Devrait effectuer la lecture du fichier.
			|Cmd-event|
							*FileReadPost*
FileReadPost		Après la lecture d'un fichier avec une commande
			":read".
			NOTE : Vim fixe les marques '[ et '] aux premières et
			dernières lignes de la lecture. Ceci peut être utilisé
			pour opérer sur les lignes qui viennent juste d'être
			lues.
							*FileReadPre*
FileReadPre		Avant la lecture d'un fichier avec un ":read".
							*FileType*
FileType		Quand l'option 'filetype' a été fixée.
			<afile> peut être utilisé pour donner le nom du
			fichier où cette option a été fixée, et <amatch> pour
			la nouvelle valeur de 'filetype'. Voir |filetypes|.
							*FileWriteCmd*
FileWriteCmd		Avant l'écriture dans un fichier, si ce n'est pas le
			tampon entier qui est écrit. Devrait effectuer
			l'écriture dans le fichier. Ne devrait pas modifier le
			tampon. Utilisez les marques '[ et '] pour récupérer
                        l'étendue des lignes. |Cmd-event|
							*FileWritePost*
FileWritePost		Après l'écriture dans un fichier, si ce n'est pas le
			tampon entier qui est écrit.
							*FileWritePre*
FileWritePre		Avant l'écriture dans un fichier, si ce n'est pas le
			tampon entier qui est écrit. Utilisez les marques '[
                        et '] pour récupérer l'étendue des lignes.
							*FilterReadPost*
FilterReadPost		Après la lecture d'un fichier depuis une commande de
			filtre. Vim cherche une correspondance du motif de
			fichier avec le nom du tampon courant, comme avec
			FilterReadPre. N'est pas déclenché si 'shelltemp' est
                        désactivée.
							*FilterReadPre* *E135*
FilterReadPre		Avant la lecture d'un fichier depuis une commande de
			filtre. Vim cherche une correspondance du motif de
			fichier avec le nom du tampon courant, et non avec le
			nom du fichier temporaire en sortie de la commande de
			filtre. N'est pas déclenché si 'shelltemp' est
                        désactivée.
	    						*FilterWritePost*
FilterWritePost		Après l'écriture dans un fichier par une commande de
			filtre, ou une comparaison (mode diff).
			Vim cherche une correspondance du motif de fichier
			avec le nom du tampon courant, comme avec
			FilterWritePre. N'est pas déclenché si 'shelltemp' est
                        désactivée.
							*FilterWritePre*
FilterWritePre		Avant l'écriture dans un fichier par une commande de
			filtre, ou une comparaison (mode diff).
			Vim cherche une correspondance du motif de fichier
			avec le nom du tampon courant, et non avec le nom du
			fichier temporaire en sortie de la commande de filtre.
                        N'est pas déclenché si 'shelltemp' est désactivée.
							*FocusGained*
FocusGained		Quand Vim obtient le focus de la souris. Seule la
			version IHM graphique et certaines versions console
			peuvent détecter cet événement.
							*FocusLost*
FocusLost		Quand Vim perd le focus de la souris. Seule la version
			IHM graphique et certaines versions console peuvent
			détecter cet événement. Peut aussi arriver lorsque
                        qu'une fenêtre de dialogue surgit.
							*FuncUndefined*
FuncUndefined		Quand une fonction utilisateur est utilisée mais n'est
			pas définie. Utile pour définir une fonction
			uniquement si elle est utilisée. <amatch> et <afile>
			sont tous deux fixés au nom de la fonction.
                        Voir |autoload-functions|.
							*GUIEnter*
GUIEnter		Après que l'IHM graphique a été lancée avec succès, et
			après l'ouverture de la fenêtre. Déclenché avant
			VimEnter quand gvim est utilisé. Peut être utilisé
			pour placer la fenêtre dans un fichier gvimrc : >
				:autocmd GUIEnter * winpos 100 50
<                                                       *InsertChange*
InsertChange            Lorsque l'on tape <Insert> en étant en mode insertion
                        ou remplacement. La variable |v:insertmode| indique
                        quel est le nouveau mode. Faites attention de ne pas
                        déplacer le curseur ou quoi que ce soit d'autre qui
                        puisse surprendre l'utilisateur.
                                                        *InsertEnter*
InsertEnter             Lorsque l'on entre dans le mode insertion. Également
                        déclenché pour les mode remplacement et remplacement
                        virtuel. La variable |v:insertmode| indique quel est
                        le mode. Faites attention de ne pas déplacer le
                        curseur ou quoi que ce soit d'autre qui puisse
                        surprendre l'utilisateur.
                                                        *InsertLeave*
InsertLeave             Lorsque l'on quitte le mode insertion. Également
                        déclenché lors de l'utilisation de CTRL-O |i_CTRL-O|.
                        Mais pas pour |i_CTRL-C|.
                                                        *MenuPopup*
MenuPopup               Juste avant d'afficher le menu popup (après avoir
                        cliqué avec le bouton droit de la souris). Utile pour
                        ajuster le menu en fonction de ce qui est sous le
                        curseur ou le pointeur de la souris.
                        Le motif est mis en correspondance avec un seul
                        caractère représentant le mode :
                                n Normal
                                v Visuel
                                o Opérateur en attente
                                i Insertion
                                c ligne de Commande
                                                        *QuickFixCmdPre*
QuickFixCmdPre          Avant qu'une commande Quickfix soit exécutée
                        (|:make|, |:lmake|, |:grep|, |:lgrep|, |:grepadd|,
                         |:lgrepadd|, |:vimgrep|, |:lvimgrep|, |:vimgrepadd|,
                         |:vimgrepadd|). Le motif est mis en correspondance
                        avec la commande qui est exécutée. Quand |:grep| est
                        utilisé mais que 'grepprg' est positionnée sur
                        "internal", le motif correspond encore à "grep". Cette
                        commande ne peut pas être utilisée pour positionner
                        les variables 'makeprg' et 'grepprg'. Si cette
                        commande produit une erreur, la commande Quickfix
                        n'est pas exécutée.
                                                        *QuickFixCmdPost*
QuickFixCmdPost         Comme QuickFixCmdPre mais après que la commande
                        Quickfix ait été exécutée, avant de sauter au premier
                        emplacement.
							*RemoteReply*
RemoteReply		Lors de la réception d'une réponse de la part d'un Vim
			qui fonctionne en tant que serveur. |server2client()|
			<amatch> est fixé à l'{IDserveur} depuis lequel la
			réponse a été envoyée, et <afile> à la chaîne de la
			réponse.
			NOTE : Même si une autocommande est définie, la
			réponse devrait être lue avec |remote_read()| pour
			être consommée.
                                                        *SessionLoadPost*
SessionLoadPost         Après avoir chargé le fichier de session créé par la
                        commande |:mksession|.
                                                        *ShellCmdPost*
ShellCmdPost            Après l'exécution d'une commande shell avec |:!cmd|,
                        |:shell|, |:make| ou |:grep|. Peut être utilisé pour
                        vérifier si un fichier a été changé.
                                                        *ShellFilterPost*
ShellFilterPost         Après l'exécution d'une commande shell avec
                        ":{range}!cmd", ":w !cmd" ou ":r !cmd". Peut être
                        utilisé pour vérifier si un fichier a été changé.
                                                        *SourcePre*
SourcePre               Avant l'exécution d'un script Vim. |:source| <afile>
                        est le nom du fichier qui est exécuté.
                                                        *SourceCmd*
SourceCmd               Pendant l'exécution d'un script Vim. |:source| <afile>
                        est le nom du fichier en cours d'exécution.
                        L'autocommande doit exécuter ce fichier. |Cmd-event|
                                                        *SpellFileMissing*
SpellFileMissing        Lorsque l'on essaie de charger un fichier
                        d'orthographe et qu'il ne peut pas être trouvé. Le
                        motif est mis en correspondance avec le langage.
                        <amatch> est le langage, 'encoding' peut également
                        avoir son importance. Voir |spell-SpellFileMissing|.
							*StdinReadPost*
StdinReadPost		Après la lecture de stdin dans le tampon, avant
			l'exécution des lignes de mode. Utilisé uniquement si
			l'argument '-' a été donné à Vim au démarrage |--|.
							*StdinReadPre*
StdinReadPre		Avant la lecture de stdin dans le tampon. Utilisé
			uniquement si l'argument '-' a été donné à Vim au
			démarrage |--|.
                                                        *SwapExists*
SwapExists              Détection d'un fichier d'échange existant lors du
                        début de l'édition d'un fichier. Seulement lorsqu'il
                        est possible de choisir un moyen de remédier à la
                        situation, lorsque Vim demanderait à l'utilisateur
                        quoi faire. La variable |v:swapname| contient le nom
                        du fichier d'échange trouvé et <afile> le nom du
                        fichier en cours d'édition. |v:swapcommand| peut
                        contenir une commande à exécuter dans le fichier
                        ouvert. Les commandes devraient positionner la
                        variable |v:swapchoice| a une chaîne de caractères
                        afin d'indiquer à Vim ce qu'il doit faire ensuite :
                                'o' pour Ouvrir le fichier en lecture seule
                                'e' pour Éditer le fichier
                                'r' pour Récupérer le fichier
                                'd' pour effacer le fichier D'échange
                                'q' pour Quitter sans éditer le fichier
                                'a' pour Abandonner comme si on avait pressé
                                         CTRL-C
                        Si cette variable est positionnée à une chaine vide,
                        l'utilisateur se verra poser la question, comme s'il
                        n'y avait eu aucune autocommande SwapExists.
                        Note : n'essayez pas de changer le tampon, les
                        résultats seraient imprévisibles.
							*Syntax*
Syntax			Quand l'option 'syntax' a été fixée.
			<afile> peut être utilisé pour donner le nom du
			fichier où cette option a été fixée, et <amatch> pour
			la nouvelle valeur de 'syntax'. Voir |:syn-on|.
                                                        *TabEnter*
TabEnter                Juste après être entré dans une page à onglet.
                        |tab-page| Après avoir déclenché l'événement WinEnter
                        et avant de déclencher l'événement BufEnter.
                                                        *TabLeave*
TabLeave                Juste avant de sortir d'une page à onglet. |tab-page|
                        Un événement WinLeave aura été déclenché auparavant.
							*TermChanged*
TermChanged		Après le changement de la valeur de 'term'. Utile pour
			recharger le fichier de syntaxe pour mettre à jour les
			couleurs, polices et autres paramètres dépendant du
			terminal. Exécuté pour tous les tampons chargés.
							*TermResponse*
TermResponse		Après que la réponse à |t_RV| a été reçue du terminal.
			La valeur de |v:termresponse| peut être utilisée pour
			effectuer certaines actions dépendamment de la version
			du terminal.
							*User*
User			Jamais exécuté automatiquement. À utiliser pour les
			autocommandes qui sont uniquement exécutées avec
			":doautocmd".
	    						*UserGettingBored*
UserGettingBored	Quand l'utilisateur frappe CTRL-C. Non, c'est pour
			rire ! :-)
                                                        *VimEnter*
VimEnter		Après toutes les initialisations du démarrage, y
			compris le chargement des fichiers vimrc, l'exécution
			des arguments "-c cmd", la création de toutes les
			fenêtres et le chargement des tampons dedans.
							*VimLeave*
VimLeave		Avant de quitter Vim, juste après l'écriture du
			fichier viminfo. N'est exécuté qu'une fois, comme
			VimLeavePre.
			Pour détecter une sortie anormale, utilisez |v:dying|.
							*VimLeavePre*
VimLeavePre		Avant de quitter Vim, juste avant l'écriture du
			fichier viminfo. N'est exécuté qu'une seule fois, s'il
			existe une correspondance avec le nom de ce qui est le
			tampon courant quand Vim est quitté.
			Essentiellement utile avec un motif "*" : >
				:autocmd VimLeavePre * call AvantDeSortir()
<			Pour détecter une sortie anormale, utilisez |v:dying|.
                                                        *VimResized*
VimResized              Après que la fenêtre Vim a changé de taille, donc au
                        moins l'un de 'lines' ou 'columns' a changé. N'est pas
                        déclenché au démarrage, cependant.
							*WinEnter*
WinEnter		Après l'entrée dans une autre fenêtre. Non déclenché
			pour la première fenêtre, quand Vim vient d'être
			lancé. Utile pour fixer la hauteur de la fenêtre.
			Si la fenêtre est pour un autre tampon, Vim exécute
			les autocommandes BufEnter après les autocommandes
			WinEnter.
			NOTE : Quand ":split nomfich" est utilisé, l'événement
			WinEnter est déclenché après le partage mais avant le
			chargement du fichier "nomfich".
							*WinLeave*
WinLeave		Avant de quitter une fenêtre. Si la fenêtre où Vim
			doit ensuite entrer contient un tampon différent, Vim
			exécutera les autocommandes BufLeave avant les
			autocommandes WinLeave (mais pas pour ":new"). Non
			utilisé pour ":qa" ou ":q" quand Vim est quitté.

==============================================================================
6. Motifs					*autocmd-patterns* *{pat}*

Le motif de fichier {motif} est traité pour établir une correspondance avec le
nom de fichier d'une de ces deux façons :
1. Quand il n'y a pas de '/' dans le motif, Vim ne recherche de
   correspondance qu'avec la « queue » du nom de fichier (sans le chemin
   d'accès initial).
2. Quand il y a un '/' dans le motif, Vim recherche une correspondance avec le
   nom de fichier court (tel que vous l'avez saisi) et le nom de fichier
   entier (après l'avoir étendu en un chemin complet et avoir résolu les liens
   symboliques).

Le motif special <buffer> ou <buffer=N> est utilisé pour les autocommandes
locales à un tampon |autocmd-buflocal|. Ce motif n'est pas mis en
correspondance avec le nom d'un tampon.

Exemples : >
	:autocmd BufRead *.txt		set et
<		Active l'option 'et' pour tous les fichiers texte. >
	:autocmd BufRead /vim/src/*.c	set cindent
<		Active l'option 'cindent' pour les fichiers C dans le
		répertoire "/vim/src". >
	:autocmd BufRead /tmp/*.c	set ts=5
<		Si "/tmp/test.c" est lié à "/home/babar/vim/src/test.c" et que
		vous commencez à éditer le fichier "/tmp/test.c", cette
		autocommande correspondra.

NOTE : Pour correspondre à une partie d'un chemin, mais pas depuis le
répertoire racine, utilisez un '*' comme premier caractère. Exemple : >
	:autocmd BufRead */doc/*.txt	set tw=78
Cette autocommande sera par exemple exécutée pour "/tmp/doc/xx.txt" et
"/usr/home/bibi/doc/yy.txt". Le nombre de répertoires n'importe pas ici.


Le nom de fichier auquel le motif doit correspondre est celui obtenu après
l'expansion des jokers. Ainsi, si vous entrez cette commande >
	:e $ROOTDIR/main.$EXT
l'argument est d'abord étendu en
	/usr/root/main.py ~
avant de pouvoir correspondre avec le motif de l'autocommande. Faites
attention à cela quand vous utilisez des événements comme FileReadCmd, la
valeur de <amatch> peut ne pas correspondre à ce que vous espérez.


Les variables d'environnement peuvent être utilisées dans un motif : >
	:autocmd BufRead $VIMRUNTIME/doc/*.txt  set expandtab
Et '~' peut être utilisé pour le répertoire personnel (si $HOME est défini) : >
	:autocmd BufWritePost ~/.vimrc	so ~/.vimrc
	:autocmd BufRead ~archive/*     set readonly
La variable d'environnement est étendue quand l'autocommande est définie, pas
quand elle est exécutée. À l'inverse de la commande !

							*file-pattern*
Le motif est interprété selon les règles généralement utilisées pour les noms
de fichiers :
	*	correspond à n'importe quelle séquence de caractères
	?	correspond à n'importe quel caractère simple
	\?	correspond à un '?'
	.	correspond à un '.'
	~	correspond à un '~'
	,	sépare des motifs
	\,	correspond à un ','
	{ }	comme \( \) dans un motif |pattern|
	,	entre { } : comme \| dans un motif |pattern|
	\	signification spéciale comme dans un motif |pattern|
	[ch]	correspond à 'c' ou 'h'
        [^ch]   correspond à tout caractère sauf 'c' et 'h'.

NOTE : Le caractère '/' est utilisé comme séparateur de chemin pour tous les
systèmes (même MS-DOS et OS/2). Cela a été décidé car la contre-oblique est
difficile à utiliser dans un motif, et pour rendre les autocommandes portables
entre les différents systèmes.

                                                        *autocmd-changes*
La correspondance avec le motif est effectuée quand un événement est
déclenché. La modification du nom du tampon dans une des autocommandes -- ou
même la suppression du tampon -- n'infléchira pas l'exécution des
autocommandes. Exemple : >

	:au BufEnter *.blabla  bdel
	:au BufEnter *.blabla  set modified

Ceci supprimera le tampon courant puis activera 'modified' dans celui qui est
devenu le tampon courant. Vim ne tient pas compte de ce que "*.blabla" ne
corresponde plus au nom de ce tampon. Il correspondait au moment où
l'événement avait été défini.

Cependant, les autocommandes locales à un tampon ne seront pas exécutées pour
un tampon qui a été détruit par |:bwipe|. Après la suppression d'un tampon
avec |:bdel| le tampon continue d'exister (mais il n'est plus listé), et donc
les autocommandes sont toujours exécutées.

==============================================================================
7. Autocommandes locales à un tampon *autocmd-buflocal* *autocmd-buffer-local*
                                        *<buffer=N>* *<buffer=abuf>* *E680*

Les autocommandes locales à un tampon sont attachées à un tampon spécifique.
Elles sont utiles si le tampon n'a pas de nom ou si le nom ne correspond à
aucun motif. Mais cela signifie également qu'elles doivent être explicitement
ajoutées à chaque tampon.

À la place d'un motif, les autocommandes locales à un tampon utilisent l'une
de ces formes :
        <buffer>        tampon courant
        <buffer=99>     tampon numéro 99
        <buffer=abuf>   utilisation de <abuf> (seulement lors de l'exécution
                        d'autocommandes) |<abuf>|

Exemples : >
        :au CursorHold <buffer>  echo 'hold'
        :au CursorHold <buffer=33>  echo 'hold'
        :au CursorHold <buffer=abuf>  echo 'hold'

Toutes les commandes pour les autocommandes fonctionnent également pour les
autocommandes locales à un tampon, utilisez simplement la chaîne spéciale à la
place du motif. Exemples : >
        :au! * <buffer>                  " supprime les autocommandes locales
                                         " à un tampon pour le tampon courant
        :au! * <buffer=33>               " supprime les autocommandes locales
                                         " à un tampon pour le tampon numéro 33
        :dobuf :au! CursorHold <buffer>  " supprime les autocommandes pour
                                         " l'événement CursorHold pour tous les
                                         " tampons
        :au * <buffer>                   " liste les autocommandes locales à
                                         " un tampon pour le tampon courant

Notez que lorsqu'une autocommande est définie pour le tampon courant, elle est
stoquée avec le numéro du tampon. Ainsi, elle utilise la forme "<buffer=12>"
où 12 est le numéro du tampon courant. Vous le verrez en listant les
autocommandes par exemple.

Pour tester la présence d'autocommandes locales à un tampon, utilisez la
fonction |exists()| comme suit : >
        :if exists("#CursorHold#<buffer=12>") | ... | endif
        :if exists("#CursorHold#<buffer>") | ... | endif " pour le tampon
                                                         " courant

Lorsqu'un tampon est détuit, ces autocommandes locales sont également
détruites, bien entendu. Notez que lorsque l'on efface un tampon, par exemple
avec |:bdel|, il est simplement supprimé de la liste, ses autocommandes sont
donc toujours présentes. Pour voir la suppression des autocommandes locales à
un tampon, utilisez : >
        :set verbose=6

Il n'est pas possible de définir une autocommande locale à un tampon pour un
tampon qui n'existe pas.

==============================================================================
8. Groupes						*autocmd-groups*

Des autocommandes peuvent être réunies au sein d'un groupe. C'est pratique
pour exécuter ou supprimer un groupe d'autocommandes. Par exemple, toutes les
autocommandes relatives à la coloration syntaxique sont réunies dans le groupe
"highlight", ce qui permet d'exécuter ":doautoall highlight BufRead" quand
l'IHM graphique est lancée.

Si aucun groupe particulier n'est sélectionné, Vim utilise le groupe par
défaut. Le groupe par défaut n'a pas de nom. Vous ne pouvez pas exécuter les
autocommandes du groupe par défaut séparément ; vous ne pouvez le faire qu'en
exécutant les autocommandes pour tous les groupes.

Normalement, quand les autocommandes sont exécutées automatiquement, Vim les
utilise pour tous les groupes. La spécification d'un groupe n'est réalisable
qu'avec ":doautocmd" ou ":doautoall", ou lors de la définition ou de la
suppression d'autocommandes.

Un nom de groupe peut contenir n'importe quel caractère sauf l'espace blanc.
Le nom de groupe "end" est réservé (y compris en majuscules).

Le nom de groupe est sensible à la casse. Notez que ce n'est pas le cas du nom
de l'événement !

							*:aug* *:augroup*
:aug[roup] {nom}	Définit le nom du groupe d'autocommandes pour les
			commandes ":autocmd" suivantes. Le nom "end" ou
			"END" sélectionne le groupe par défaut.

						*:augroup-delete* *E367*
:aug[roup]! {nom}	Supprime le groupe d'autocommandes {nom}. N'utilisez
			pas ceci s'il reste une autocommande qui utilise ce
			groupe ! Cela n'est pas vérifié.

Pour entrer des autocommandes pour un groupe en particulier, utilisez cette
méthode :
1. Sélectionnez le groupe avec ":augroup {nom}".
2. Supprimez toutes les anciennes autocommandes avec ":au!".
3. Définissez les autocommandes.
4. Revenez au groupe par défaut avec "augroup END".

Exemple : >

	:augroup decompactage
	:  au!
	:  au BufEnter *.gz	%!gunzip
	:augroup END

Cela évite d'avoir des autocommandes définies deux fois (p. ex., après un
nouveau sourcement du fichier vimrc).

==============================================================================
9. Exécuter des autocommandes				*autocmd-execute*

Vim peut aussi exécuter des autocommandes non automatiquement. C'est utile si
vous avez modifié les autocommandes, ou quand Vim a exécuté de mauvaises
autocommandes (p. ex., quand la correspondance avec le nom de fichier était
mauvaise).

NOTE : L'option 'eventignore' s'applique ici aussi. Les commandes reliées aux
événements listés dans cette option ne pourront pas s'exécuter.

					*:do* *:doau* *:doautocmd* *E217*
:do[autocmd] [groupe] {even} [nomfich]
			Applique les autocommandes correspondant à [nomfich]
			(défaut : nom du fichier courant) pour {even} au
			tampon courant.
			Vous pouvez utiliser ceci quand le nom de fichier
			courant ne correspond pas au bon motif, après avoir
			changé des paramètres, ou pour exécuter des
			autocommandes pour un certain événement.
			Il est également possible d'utiliser ceci à
			l'intérieur d'une autocommande, vous pouvez alors
			baser les autocommandes d'une extension sur une autre
			extension. Exemple : >
				:au Bufenter *.cpp so ~/.vimrc_cpp
				:au Bufenter *.cpp doau BufEnter x.c
<			Attention aux boucles sans fin !  Voir
			|autocmd-nested|.

			Quand l'argument [groupe] n'est pas donné, Vim exécute
			les autocommandes pour tous les groupes. Quand il est
			donné, Vim exécute uniquement les autocommandes
			correspondant à [groupe]. NOTE : Si vous utilisez un
			nom de groupe non défini, Vim émet un message
			d'erreur.

                        Après l'application des autocommandes, les lignes de
                        modes sont analysées, ces dernières peuvent donc
                        changer des paramètres qui avaient été mis en place
                        par les autocommandes.

						*:doautoa* *:doautoall*
:doautoa[ll] [groupe] {even} [nomfich]
			Comme ":doautocmd", mais applique les autocommandes à
			chaque tampon chargé. Notez que {nomfich} est utilisé
                        pour sélectionner les autocommandes, pas les tampons
                        auxquels elles sont appliquées.
                        Attention ! N'utilisez pas ceci pour les autocommandes
                        qui suppriment un tampon, changent pour un autre tampon
                        ou modifient le contenu d'un tampon ; le résultat
                        serait imprévisible. Cette commande est destinée aux
                        autocommandes qui fixent des options, modifient la
                        coloration, et des choses comme ça.

==============================================================================
10. Utiliser des autocommandes				*autocmd-use*

Il existe quatre ensembles d'événements possibles pour l'ÉCRITURE dans des
fichiers. Vim n'en utilise qu'un seul à la fois :

    BufWriteCmd    BufWritePre     BufWritePost	     lors de l'écriture du
							tampon entier
		   FilterWritePre  FilterWritePost   lors de l'écriture dans un
							fichier temp de filtre
    FileAppendCmd  FileAppendPre   FileAppendPost    lors de l'ajout dans un
							fichier
    FileWriteCmd   FileWritePre    FileWritePost     pour tout autre écriture
							dans un fichier

Lorsqu'il existe une autocommande "*Cmd", Vim suppose qu'elle effectuera
l'enregistrement. Il n'y aura pas d'enregistrement ultérieur, et les autres
événements ne seront pas déclenchés. |Cmd-event|

NOTE : Les commandes *WritePost devraient annuler les changements apportés au
tampon par les commandes *WritePre ; sans cela, l'enregistrement du fichier
aura pour effet de bord de modifier le tampon.

Avant d'exécuter les autocommandes, le tampon duquel les lignes doivent être
écrites devient temporairement le tampon courant. À moins que les
autocommandes ne changent le tampon courant ou suppriment le tampon courant
précédent, ce dernier redeviendra à nouveau le tampon courant.

Les autocommandes *WritePre et *AppendPre ne doivent pas supprimer le tampon
duquel les lignes doivent être écrites.

Les marques '[ et '] ont une position spéciale :
- Avant l'événement *ReadPre, la marque '[ est fixée à la ligne juste
  au-dessus d'où les nouvelles lignes seront insérées.
- Avant l'événement *ReadPost, la marque '[ est fixée à la première ligne qui
  vient d'être lue, la marque '] à la dernière ligne.
- Avant l'exécution des autocommandes *WriteCmd*, *WritePre et *AppendPre, la
  marque '[ est fixée à la première ligne qui devra être écrite, la marque ']
  à la dernière ligne.
Attention ! '[ et '] changent quand des commandes qui modifient le tampon sont
utilisées.

Dans les commandes qui attendent un nom de fichier, vous pouvez utiliser
"<afile>" pour donner le nom du fichier qui doit être lu |:<afile>| (vous
pouvez aussi utiliser "%" pour le nom du fichier courant).
   "<abuf>" peut être utilisé pour donner le numéro du tampon courant
effectif. Cela marche aussi pour les tampons qui n'ont pas de nom ; mais pas
pour les fichiers sans tampon (p. ex., avec ":r fichier").

							*gzip-example*
Exemple (pour lire et enregistrer des fichiers compactés) : >

	:augroup gzip
	:  autocmd!
	:  autocmd BufReadPre,FileReadPre	*.gz set bin
	:  autocmd BufReadPost,FileReadPost	*.gz '[,']!gunzip
	:  autocmd BufReadPost,FileReadPost	*.gz set nobin
	:  autocmd BufReadPost,FileReadPost	*.gz execute ":doautocmd BufReadPost " . expand("%:r")
	:  autocmd BufWritePost,FileWritePost	*.gz !mv <afile> <afile>:r
	:  autocmd BufWritePost,FileWritePost	*.gz !gzip <afile>:r
	
	:  autocmd FileAppendPre		*.gz !gunzip <afile>
	:  autocmd FileAppendPre		*.gz !mv <afile>:r <afile>
	:  autocmd FileAppendPost		*.gz !mv <afile> <afile>:r
	:  autocmd FileAppendPost		*.gz !gzip <afile>:r
	:augroup END

Le groupe "gzip" est utilisé pour permettre de supprimer toutes les
autocommandes existantes avec ":autocmd!", pour le cas où le fichier serait
sourcé deux fois.

("<afile>:r" est le nom du fichier sans son extension, voir |:_%:|.)

Les commandes exécutées pour les événements BufNewFile, BufRead/BufReadPost,
BufWritePost, FileAppendPost et VimLeave ne modifient pas le drapeau de
modification du fichier. Quand vous décompactez le tampon avec les
autocommandes BufReadPost, vous pouvez toujours quitter avec ":q". Quand vous
utilisez ":undo" dans BufWritePost pour annuler les changements effectués par
les commandes BufWritePre, vous pouvez toujours faire ":q" ("ZZ" fonctionnera
aussi). Si vous souhaitez que le tampon soit marqué comme modifié, activez
l'option 'modified'.

Pour exécuter des commandes du mode Normal à partir d'une autocommande,
utilisez la commande ":normal". Mais soyez prudent ! si la commande du mode
Normal n'est pas terminée, l'utilisateur devra taper des caractères
supplémentaires (p. ex., après ":normal m", vous devrez entrer le nom d'une
marque).

Si vous ne souhaitez pas que le tampon soit considéré comme modifié après
l'avoir changé, désactivez l'option 'modified'. Cela permet de quitter le
tampon avec ":q" au lieu de ":q!".

						    *autocmd-nested* *E218*
Par défaut, les autocommandes ne s'imbriquent pas. Si vous utilisez ":e" ou
":w" dans une autocommande, Vim n'exécutera pas les autocommandes BufRead et
BufWrite pour ces commandes. Pour autoriser l'imbrication, utilisez le drapeau
"nested" avec les commandes pour lesquelles vous la souhaitez. Par exemple : >

	:autocmd FileChangedShell *.c nested e!

L'imbrication est limitée à 10 niveaux, pour sortir des boucles récursives.

Il est possible d'utiliser la commande ":au" dans une autocommande. Cela peut
donner une commande qui s'auto-modifie ! Cela peut être utile pour une
autocommande qui ne devrait s'exécuter qu'une seule fois.

Si vous voulez ignorer les autocommandes pour une commande, utilisez le
modificateur de commande |:noautocmd| ou l'option 'eventignore'.

NOTE : Lors de la lecture d'un fichier (avec ":read fichier" ou une commande
de filtre), si la dernière ligne du fichier ne contient pas de <EOL>, Vim se
le rappellera. Lors du prochain enregistrement (avec ":write fichier" ou une
commande de filtre), si la même ligne est à nouveau écrite comme dernière
ligne dans un fichier ET que 'binary' est activé, Vim n'ajoutera pas de <EOL>.
Cela permet à une commande de filtre exécutée sur les lignes juste lues
d'écrire le fichier tel qu'il vient d'être lu, et à une commande d'écriture
sur les lignes juste filtrées d'écrire le fichier tel qu'il vient d'être lu
depuis le filtre. Par exemple, pour enregistrer un fichier compacté, on peut
aussi employer cette méthode : >

	:autocmd FileWritePre	*.gz	set bin|'[,']!gzip
	:autocmd FileWritePost	*.gz	undo|set nobin
<
						    *autocommand-pattern*
Vous pouvez spécifier des motifs multiples, séparés par des virgules. Voici
quelques exemples : >

  :autocmd BufRead   *	      set tw=79 nocin ic infercase fo=2croq
  :autocmd BufRead   .lettre  set tw=72 fo=2tcrq
  :autocmd BufEnter  .lettre  set dict=/usr/lib/dict/words
  :autocmd BufLeave  .lettre  set dict=
  :autocmd BufRead,BufNewFile *.c,*.h	set tw=0 cin noic
  :autocmd BufEnter  *.c,*.h  abbr FOR for (i = 0; i < 3; ++i)<CR>{<CR>}<Esc>O
  :autocmd BufLeave  *.c,*.h  unabbr FOR

Pour les fichiers de type Makefile ("makefile", "Makefile", "imakefile",
"makefile.unix", etc.) : >

	:autocmd BufEnter  ?akefile*	set include=^s\=include
	:autocmd BufLeave  ?akefile*	set include&

Pour toujours commencer l'édition des fichiers C à la première fonction : >

	:autocmd BufRead   *.c,*.h	1;/^{

Sans le "1;" ci-dessus, la recherche débuterait de l'endroit où le fichier a
été ouvert, plutôt que du début du fichier.

						    *skeleton* *template*
Pour lire un squelette (modèle) de fichier lors de l'ouverture d'un nouveau
fichier : >

	:autocmd BufNewFile  *.c	0r ~/vim/squelette.c
	:autocmd BufNewFile  *.h	0r ~/vim/squelette.h
	:autocmd BufNewFile  *.java	0r ~/vim/squelette.java

Pour insérer la date et l'heure courante dans un fichier ".html" lors de son
enregistrement : >

	:autocmd BufWritePre,FileWritePre *.html   ks|call DerModif()|'s
	:fun DerModif()
	:  if line("$") > 20
	:    let l = 20
	:  else
	:    let l = line("$")
	:  endif
	:  exe "1," . l . "g/Dernière modification : /s/Dernière modification : .*/Dernière modification : " .
	:  \ strftime("%d %b %Y %X %Z")
	:endfun

Vous devrez avoir une ligne "Dernière modification : <date heure>" dans les
20 première lignes du fichier pour que cela fonctionne. Vim remplace "<date
heure>" (et tout ce qui suit dans la même ligne) par la date et l'heure
courante.
   Dissection :
	ks		 marque la position courante avec 's'
	call DerModif()  appelle la fonction DerModif() pour effectuer le
			    travail
	's		 revient à l'ancienne position
La fonction DerModif() teste si le fichier fait moins de 20 lignes, puis
utilise la commande ":g" pour trouver les lignes qui contiennent "Dernière
modification : ". Pour ces lignes, la commande ":s" est exécutée pour
remplacer les date et heure existantes par les courantes. La commande
":execute" est utilisée pour pouvoir employer une expression avec les
commandes ":g" et ":s". La date et l'heure sont obtenues avec la fonction
strftime(). Vous pouvez en modifier les arguments pour obtenir une autre
chaîne d'horodatage.

Quand vous entrez ":autocmd" sur la ligne de commande, le complètement des
noms d'événements et de commandes peut être effectué (avec <Tab>, CTRL-D,
etc.) là où c'est approprié.

Vim exécute toutes les autocommandes correspondantes dans l'ordre où vous les
avez spécifiées. Il est recommandé de placer en premier les autocommandes
devant être exécutées pour tous les fichiers (celles qui utilisent le motif
"*" comme motif de fichier). Cela vous permet de définir les paramètres que
vous souhaitez par défaut pour tous vos fichiers ; s'il y a ensuite d'autres
autocommandes correspondantes, elles recouvriront ces valeurs. Ainsi, lorsque
vous ouvrez un fichier, il utilise au moins les paramètres par défaut, même si
le fichier précédent avait fixé ces paramètres différemment.
   NOTE : "*" correspondra aussi aux fichiers débutant par '.', contrairement
aux shells Unix.

						    *autocmd-searchpat*
Les autocommandes ne modifient pas les motifs de recherche courants. Vim
enregistre les motifs de recherche courants avant d'exécuter les
autocommandes, puis les restaure après qu'elles ont fini. Cela signifie que
les autocommandes n'affectent pas les chaînes mises en surbrillance avec
l'option 'hlsearch'. À l'intérieur des autocommandes, vous pouvez toujours
utiliser les motifs de recherche normalement, p. ex., avec la commande "n".
   Si vous souhaitez qu'une autocommande fixe le motif de recherche afin qu'il
reste utilisable après que l'autocommande a fini, utilisez la commande
":let @/ =".
   La surbrillance de recherche ne peut pas être désactivée avec ":nohlsearch"
dans une autocommande. Utilisez le drapeau 'h' de l'option 'viminfo' pour
désactiver la surbrillance de recherche au démarrage de Vim.

						    *Cmd-event*
Quand un des événements "*Cmd" est utilisé, les autocommandes correspondantes
sont censées effectuer la lecture ou l'enregistrement du fichier. Ceci peut
être utilisé lorsque vous travaillez avec des fichiers d'un type particulier,
par exemple sur un système distant.
   ATTENTION ! Si vous utilisez ces événements de mauvaise façon, cela peut
avoir comme effet de rendre impossible la lecture ou l'enregistrement des
fichiers correspondants. Assurez-vous d'abord de bien tester vos
autocommandes. Le mieux est d'utiliser un motif qui ne pourra jamais
correspondre à un nom de fichier normal, par exemple "ftp://*".

Quand vous définissez un événement BufReadCmd, il sera difficile pour Vim de
recouvrer une session d'édition plantée. Lors du recouvrement à partir du
fichier original, Vim lit uniquement les parties du fichier qu'il ne trouve
pas dans le fichier d'échange. Comme cela n'est pas possible avec BufReadCmd,
utilisez la commande |:preserve| pour vous assurer que le fichier original ne
sera plus nécessaire pour le recouvrement. Cela n'est utile qu'au cas où le
fichier a été modifié.

Pour les commandes de lecture et d'écriture de fichiers, la variable
|v:cmdarg| contient les arguments "++enc=" et "++ff=" actuellement actifs. Ils
peuvent être utilisés pour la commande qui lit ou écrit le fichier. La
variable |v:cmdbang| vaut un si "!" a été utilisé et zéro sinon.

Voir $VIMRUNTIME/plugin/netrw.vim pour avoir des exemples.

==============================================================================
11. Désactiver des autocommandes                        *autocmd-disable*

Pour désactiver des autocommandes temporairement, utilisez l'option
'eventignore'. Notez que cela peut entrainer un comportement inattendu, aussi
prenez soin de restaurer la valeur de l'option 'eventignore' par la suite, en
utilisant un bloc |:try| avec |:finally|.

                                                        *noautocmd* *:noa*
Pour désactiver les autocommandes juste le temps d'une commande, utilisez le
modificateur de commande ":noautocmd". Cela positionnera 'eventignore' à la
valeur 'all' le temps de la commande suivante. Exemple : >

        :noautocmd w fname.gz

Cela écrira le fichier sans déclencher les autocommandes définies par le
greffon gzip.


 vim:tw=78:ts=8:ft=help:norl:
